 # -*- coding: utf-8 -*-
"""
0.5 Гр: биологически обоснованная модель с «ультрамедленной» фракцией (Model C+)

Суть:
  - Состояния: [D_s, D_c, D_u, pATM_f, pATM_s, gH2AX]
  - Dc мигрирует в Du со скоростью k_cu
  - Du репарируется очень медленно (k_u)
  - Вклад Du в ATM ослаблен: w_du = s_du * w_dc, s_du∈[0,1]
  - В момент t=0 часть сложных уже в «ультрамедленных»: доли π_u^(γ), π_u^(n)

Вывод:
- Параметры лучшего фита, chi2, AIC
- Графики gH2AX и pATM для γ/нейтронов
- Остатки (z-score) по точкам
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
from scipy.optimize import least_squares

# ---------- Визуал ----------
plt.rcParams.update({
    'figure.figsize': (13, 6),
    'font.size': 12,
    'axes.labelsize': 13,
    'axes.grid': True,
    'grid.alpha': 0.3,
    'legend.frameon': False
})

# ---------- Данные ----------
DOSE_Gy = 0.5
LET_GAMMA   = 0.2
LET_NEUTRON = 60.0
t_exp = np.array([0.5, 2, 4, 6, 24], dtype=float)

data_gamma = {
    "gh2ax":     np.array([11.9, 8.85, 7.01, 6.06, 2.65], dtype=float),
    "gh2ax_err": np.array([0.31, 0.56, 0.51, 0.48, 0.14], dtype=float),
    "patm":      np.array([6.91, 4.65, 3.56, 2.83, 0.93], dtype=float),
    "patm_err":  np.array([0.39, 0.56, 0.43, 0.53, 0.25], dtype=float),
}
data_neutron = {
    "gh2ax":     np.array([10.63, 9.51, 8.86, 7.57, 6.00], dtype=float),
    "gh2ax_err": np.array([0.80, 0.37, 0.63, 0.47, 0.53], dtype=float),
    "patm":      np.array([6.49, 4.72, 3.95, 3.53, 2.41], dtype=float),
    "patm_err":  np.array([0.33, 0.64, 0.82, 0.51, 0.68], dtype=float),
}

# ---------- Помощники ----------
def aic(chi2_val, k): return 2*k + chi2_val
def chi2(res): return float(np.sum(res**2))

# ---------- Доли сложных от LET ----------
def split_damage(dose_Gy, LET, theta):
    """ Возвращает (D_s0, D_c0, f_c) в дозо-единицах """
    f_min, f_max, LET50 = theta['f_min'], theta['f_max'], theta['LET50']
    f_c = f_min + (f_max - f_min) * (LET / (LET + LET50 + 1e-9))
    f_c = np.clip(f_c, 1e-6, 1.0 - 1e-6)
    D_tot = dose_Gy
    return (1.0 - f_c) * D_tot, f_c * D_tot, f_c

# ---------- Модель C+ ----------
# Состояния: [D_s, D_c, D_u, pATM_f, pATM_s, gH2AX]
def rhs_Cplus(t, y, p):
    D_s, D_c, D_u, pATM_f, pATM_s, gH2AX = y
    # простые
    dD_s = -p['k_rs'] * D_s
    # сложные (MM) с утечкой в ультрамедленные
    dD_c = -(p['V_rc'] * D_c) / (p['K_rc'] + D_c + 1e-9) - p['k_cu'] * D_c
    # ультрамедленные
    dD_u = -p['k_u'] * D_u + p['k_cu'] * D_c
    # сигнализация ATM: Du сигналит слабее: w_du = s_du * w_dc
    w_du = p['s_du'] * p['w_dc']
    weighted = D_s + p['w_dc'] * D_c + w_du * D_u
    prod_f = (p['V_af'] * weighted) / (p['K_m'] + weighted + 1e-9)
    dpATM_f = prod_f - p['k_df'] * pATM_f
    dpATM_s = p['k_as'] * pATM_f - p['k_ds'] * pATM_s
    dgH2AX  = p['k_p'] * (pATM_f + pATM_s) - p['k_g'] * gH2AX
    return [dD_s, dD_c, dD_u, dpATM_f, dpATM_s, dgH2AX]

def simulate_Cplus(params_g, params_n, LET, dose_Gy, t_eval, theta, pi_g, pi_n):
    # стартовая доля ультрамедленных
    D_s0, D_c0, _ = split_damage(dose_Gy, LET, theta)
    pi = pi_g if LET == LET_GAMMA else pi_n
    D_u0 = pi * D_c0
    D_c0 = (1.0 - pi) * D_c0
    y0 = [D_s0, D_c0, D_u0, 0.0, 0.0, 0.0]
    p = params_g if LET == LET_GAMMA else params_n
    return solve_ivp(lambda t,y: rhs_Cplus(t,y,p),
                     (0.0, max(t_eval)), y0, t_eval=t_eval,
                     method='LSODA', rtol=1e-6, atol=1e-8)

# ---------- Вектор параметров C+ ----------
# Список параметров (общие кинетики одинаковы для γ и n — парсимония):
# [k_rs, V_rc, K_rc, V_af, K_m, k_df, k_as, k_ds, k_p, k_g, w_dc, LET50, f_min, f_max, k_u, k_cu, s_du, pi_g, pi_n]
def pack_Cplus_vec(p_base, th, k_u, k_cu, s_du, pi_g, pi_n):
    return np.array([
        p_base['k_rs'], p_base['V_rc'], p_base['K_rc'], p_base['V_af'], p_base['K_m'],
        p_base['k_df'], p_base['k_as'], p_base['k_ds'], p_base['k_p'], p_base['k_g'],
        p_base['w_dc'],
        th['LET50'], th['f_min'], th['f_max'],
        k_u, k_cu, s_du, pi_g, pi_n
    ], dtype=float)

def unpack_Cplus_vec(x):
    p_base = {
        'k_rs':x[0],'V_rc':x[1],'K_rc':x[2],'V_af':x[3],'K_m':x[4],
        'k_df':x[5],'k_as':x[6],'k_ds':x[7],'k_p':x[8],'k_g':x[9],'w_dc':x[10]
    }
    th = {'LET50':x[11],'f_min':x[12],'f_max':x[13]}
    k_u, k_cu, s_du, pi_g, pi_n = x[14], x[15], x[16], x[17], x[18]
    # один и тот же набор кинетик для γ и n
    p_g = dict(p_base, k_u=k_u, k_cu=k_cu, s_du=s_du)
    p_n = dict(p_base, k_u=k_u, k_cu=k_cu, s_du=s_du)
    return p_g, p_n, th, pi_g, pi_n

# ---------- Остатки (взвешенные) ----------
def residuals_Cplus(x):
    p_g, p_n, th, pi_g, pi_n = unpack_Cplus_vec(x)
    # разумные границы
    if (th['f_min'] < 0) or (th['f_max'] > 1) or (th['f_max'] <= th['f_min']) \
       or (p_g['k_u'] <= 0) or (p_g['k_cu'] < 0) or (p_g['s_du'] < 0) or (p_g['s_du'] > 1) \
       or (pi_g < 0) or (pi_g > 0.3) or (pi_n < 0) or (pi_n > 0.6):
        return np.ones(4*len(t_exp))*1e3
    sol_g = simulate_Cplus(p_g, p_n, LET_GAMMA,   DOSE_Gy, t_exp, th, pi_g, pi_n)
    sol_n = simulate_Cplus(p_g, p_n, LET_NEUTRON, DOSE_Gy, t_exp, th, pi_g, pi_n)
    if (not sol_g.success) or (not sol_n.success):
        return np.ones(4*len(t_exp))*1e3
    r = []
    # gH2AX: индекс 5
    r += [ (sol_g.y[5] - data_gamma["gh2ax"])     / (data_gamma["gh2ax_err"]+1e-9) ]
    r += [ ((sol_g.y[3]+sol_g.y[4]) - data_gamma["patm"]) / (data_gamma["patm_err"]+1e-9) ]
    r += [ (sol_n.y[5] - data_neutron["gh2ax"])   / (data_neutron["gh2ax_err"]+1e-9) ]
    r += [ ((sol_n.y[3]+sol_n.y[4]) - data_neutron["patm"]) / (data_neutron["patm_err"]+1e-9) ]
    return np.concatenate(r)

# ---------- Инициализации ----------
# старт вокруг прежних оценок (были у A — используем как базу для общих кинетик)
p0 = {'k_rs':1.59468,'V_rc':1.44790,'K_rc':0.72478,'V_af':117.19992,'K_m':0.84902,
      'k_df':6.48823,'k_as':0.65498,'k_ds':0.04304,'k_p':10.27093,'k_g':4.73377,'w_dc':1.57827}
th0 = {'LET50':6.51001,'f_min':0.35742,'f_max':0.62659}

# старт для C+
k_u0  = 0.005   # ч^-1  (t1/2 ~ 138 ч)

k_cu0 = 0.02    # ч^-1  (медленная миграция Dc->Du)
s_du0 = 0.5     # Du сигналит в 2 раза слабее
pi_g0 = 0.05    # малая доля у γ
pi_n0 = 0.25    # больше у нейтронов

x0 = pack_Cplus_vec(p0, th0, k_u0, k_cu0, s_du0, pi_g0, pi_n0)

# границы (11 кинетик + 3 LET + 5 C+ = 19)
lb_base = np.array([
    1e-3, 1e-3, 1e-4, 1e-2, 1e-4, 1e-3, 1e-4, 1e-4, 1e-3, 1e-3, 0.1,   # общие кинетики
    1e-3, 0.05, 0.20                                                    # LET-гиперпараметры
], dtype=float)
ub_base = np.array([
    5.0, 10.0, 10.0, 500.0, 10.0, 20.0, 5.0, 1.0, 50.0, 20.0, 10.0,
    200.0, 0.60, 0.98
], dtype=float)
lb_Cp_tail = np.array([1e-4, 0.0, 0.0, 0.0, 0.0], dtype=float)       # [k_u, k_cu, s_du, pi_g, pi_n]
ub_Cp_tail = np.array([5e-2, 5e-1, 1.0, 0.30, 0.60], dtype=float)

lb = np.concatenate([lb_base, lb_Cp_tail])
ub = np.concatenate([ub_base, ub_Cp_tail])

print("="*70)
print("ФИТ МОДЕЛИ C+ (Du, миграция, ослабленный вклад Du)")
res = least_squares(residuals_Cplus, x0, bounds=(lb, ub),
                    method='trf', max_nfev=40000, ftol=1e-9, xtol=1e-9, gtol=1e-9, verbose=2)

chi2_Cp = chi2(res.fun); k_Cp = res.x.size; AIC_Cp = aic(chi2_Cp, k_Cp)
p_g, p_n, th, pi_g, pi_n = unpack_Cplus_vec(res.x)

print("\nИТОГИ C+:")
print("Общие кинетики (γ==нейтроны):")
for k,v in p_g.items():
    print(f"{k:>6s} = {v:10.5f}")
print("Гиперпараметры LET и доли:")
for k,v in th.items(): print(f"{k:>6s} = {v:10.5f}")
print(f"{'pi_g':>6s} = {pi_g:10.5f}   (γ)")
print(f"{'pi_n':>6s} = {pi_n:10.5f}   (нейтроны)")
print(f"\nchi2={chi2_Cp:.2f} | k={k_Cp} | AIC={AIC_Cp:.2f}")

# Оценка долей сложных (до разделения) и эфф. инициализаций
_, _, f_c_g = split_damage(DOSE_Gy, LET_GAMMA,   th)
_, _, f_c_n = split_damage(DOSE_Gy, LET_NEUTRON, th)
print("\nДоли сложных ДО разделения: f_c(γ)≈%.3f, f_c(n)≈%.3f" % (f_c_g, f_c_n))
print("Эффективное начальное разделение сложных:")
print("  γ: Dc -> (1-π_g)·Dc, Du -> π_g·Dc")
print("  n: Dc -> (1-π_n)·Dc, Du -> π_n·Dc")

# ---------- Графики ----------
t_model = np.linspace(0, 24, 200)
sol_g = simulate_Cplus(p_g, p_n, LET_GAMMA, DOSE_Gy, t_model, th, pi_g, pi_n)
sol_n = simulate_Cplus(p_g, p_n, LET_NEUTRON, DOSE_Gy, t_model, th, pi_g, pi_n)

fig, axes = plt.subplots(1, 2, figsize=(13,5), sharex=True)

# gH2AX
axes[0].plot(t_model, sol_g.y[5],  '-', lw=2, color='blue', label='Mодель γ')
axes[0].plot(t_model, sol_n.y[5],  '-', lw=2, color='red', label='Mодель n')
axes[0].errorbar(t_exp, data_gamma["gh2ax"], yerr=data_gamma["gh2ax_err"], fmt='o', color='blue', ecolor='blue', capsize=4, label='Эксп γ')
axes[0].errorbar(t_exp, data_neutron["gh2ax"], yerr=data_neutron["gh2ax_err"], fmt='o', color='red', ecolor='red', capsize=4, label='Эксп n')
axes[0].axvline(0.5, ls='--', lw=1, alpha=0.4)
axes[0].set_xlabel('Время (ч)'); axes[0].set_ylabel('gH2AX (усл. ед.)'); axes[0].set_title('gH2AX')
axes[0].legend(ncol=2, fontsize=10)

# pATM
axes[1].plot(t_model, sol_g.y[3]+sol_g.y[4],  '-', lw=2, color='blue', label='Mодель γ')
axes[1].plot(t_model, sol_n.y[3]+sol_n.y[4],  '-', lw=2, color='red', label='Mодель n')
axes[1].errorbar(t_exp, data_gamma["patm"], yerr=data_gamma["patm_err"], fmt='o',color='blue', ecolor='blue', capsize=4, label='Эксп γ')
axes[1].errorbar(t_exp, data_neutron["patm"], yerr=data_neutron["patm_err"], fmt='o',color='red', ecolor='red', capsize=4, label='Эксп n')
axes[1].axvline(0.5, ls='--', lw=1, alpha=0.4)
axes[1].set_xlabel('Время (ч)'); axes[1].set_ylabel('pATM (усл. ед.)'); axes[1].set_title('pATM')
axes[1].legend(ncol=2, fontsize=10)

plt.tight_layout()
plt.savefig('modelCplus_0p5Gy.png', dpi=300)
plt.show()

# ---------- Остатки в узлах для C+ ----------
def node_res(sol, obs1, err1, obs2, err2):
    gh = sol.y[5]; pa = sol.y[3] + sol.y[4]
    r1 = (gh - obs1) / (err1 + 1e-9)
    r2 = (pa - obs2) / (err2 + 1e-9)
    return r1, r2

sol_g_nodes = simulate_Cplus(p_g, p_n, LET_GAMMA, DOSE_Gy, t_exp, th, pi_g, pi_n)
sol_n_nodes = simulate_Cplus(p_g, p_n, LET_NEUTRON, DOSE_Gy, t_exp, th, pi_g, pi_n)

rg_gh, rg_pa = node_res(sol_g_nodes, data_gamma["gh2ax"], data_gamma["gh2ax_err"],
                        data_gamma["patm"],  data_gamma["patm_err"])
rn_gh, rn_pa = node_res(sol_n_nodes, data_neutron["gh2ax"], data_neutron["gh2ax_err"],
                        data_neutron["patm"],  data_neutron["patm_err"])

print("\nОстатки (z-скор) Модель C+ — γ:")
print("  gH2AX:", np.round(rg_gh, 2))
print("  pATM: ", np.round(rg_pa,  2))
print("Остатки (z-скор) Модель C+ — нейтроны:")
print("  gH2AX:", np.round(rn_gh, 2))
print("  pATM: ", np.round(rn_pa,  2))


РЕЗУЛЬТАТЫ
ФИТ МОДЕЛИ C+ (Du, миграция, ослабленный вклад Du)
   Iteration     Total nfev        Cost      Cost reduction    Step norm     Optimality   
       0              1         1.8736e+03                                    6.12e+04    
       1              2         2.0632e+02      1.67e+03       1.32e+00       8.93e+03    
       2              3         2.7723e+01      1.79e+02       9.18e+00       2.19e+04    
       3              4         8.6299e+00      1.91e+01       1.08e+01       1.46e+02    
       4              6         7.8510e+00      7.79e-01       2.70e+00       3.04e+02    
       5              7         3.6913e+00      4.16e+00       2.53e-01       4.63e+02    
       6             11         3.6880e+00      3.37e-03       4.45e-03       5.84e+01    
       7             12         3.6622e+00      2.58e-02       4.95e-04       5.29e+01    
       8             13         3.6268e+00      3.54e-02       9.74e-04       7.45e+00    
       9             14         3.5947e+00      3.21e-02       1.37e-03       2.69e+01    
      10             15         3.5664e+00      2.82e-02       1.15e-02       1.07e+02    
      11             24         3.5664e+00      9.98e-09       3.06e-07       3.16e+01    
      12             25         3.5664e+00      8.14e-08       8.13e-08       1.95e+01    
`xtol` termination condition is satisfied.
Function evaluations 25, initial cost 1.8736e+03, final cost 3.5664e+00, first-order optimality 1.95e+01.

ИТОГИ C+:
Общие кинетики (γ==нейтроны):
  k_rs =    1.30524
  V_rc =    1.37609
  K_rc =    0.65230
  V_af =  140.33535
   K_m =    0.87532
  k_df =    6.30090
  k_as =    0.57916
  k_ds =    0.09342
   k_p =   10.63274
   k_g =    5.15634
  w_dc =    1.06114
   k_u =    0.02174
  k_cu =    0.03306
  s_du =    0.34430
Гиперпараметры LET и доли:
 LET50 =    8.42317
 f_min =    0.44097
 f_max =    0.55377
  pi_g =    0.06974   (γ)
  pi_n =    0.19862   (нейтроны)

chi2=7.13 | k=19 | AIC=45.13

Доли сложных ДО разделения: f_c(γ)≈0.444, f_c(n)≈0.540
Эффективное начальное разделение сложных:
  γ: Dc -> (1-π_g)·Dc, Du -> π_g·Dc
  n: Dc -> (1-π_n)·Dc, Du -> π_n·Dc


Остатки (z-скор) Модель C+ — γ:
  gH2AX: [-0.39  0.45  0.06  0.24 -0.44]
  pATM:  [-0.45 -0.79 -0.46  0.25  1.26]
Остатки (z-скор) Модель C+ — нейтроны:
  gH2AX: [ 1.03 -0.06 -0.94  0.86 -0.46]
  pATM:  [ 0.23 -0.42  0.05  0.64  0.54]